<html>
  <head>
  </head>
  <body>
    <h1>Git---</h1>
    <p class="question">¿Qué es un sistema de control de versiones?</p>
    <p class="answer">Un sistema de control de versiones (CVS) te permite realizar un seguimiento de la historia de una colección de archivos
      y además incluye la funcionalidad de revertir a una versión anterior.a colección de archivos usualmente es
      código fuente de algún lenguaje de programación, sin embargo, un sistema de
      control de versiones funciona con cualquier tipo de archivo</p>

     <p class="question">¿Qué es sistema de control de versiones distribuidas?</p>
    <p class='answer'>Un sistema de control de versiones distribuida tiene un servidor central para guardar el repositorio y cada ususario puede hacer
       una copia completa del repositorio central y por ser una copia completa tiene las misma funcionalidades que el repositoriuo original</p>
       <img src="whatISgit.png" style="width:700px;height:500px;">
       <p class="question">¿Qué es Git</p>
      <p class='answer'>Es un sistema de control de versiones distribuida que tiene su origen  a partir del del desarrollo de kernel de Linux.
        Es muy utilizado por proyectos comerciales de verciones como Android o Eclipse.
      Git modela sus datos más como un conjunto de instantáneas de un mini sistema de archivos Cada vez que confirmas un cambio, o guardas el
      estado de tu proyecto en Git </p>

      <p class="subtitulo">El repositorio local</p>
      <p class="content">Luego de clonar o crear un repositorio el usuario tiene una copia completa del
        repositorio, y puede realizar operaciones de control de versiones contra este
        repositorio local, como por ejemplo crear nuevas versiones, revertir cambios, etc.
        El flujo de trabajo básico en Git es algo así
    <ul>
      <li>Modificas una serie de archivos en tu directorio de trabajo (working directory).</li>
      <li> Añadís instantáneas de los archivos a tu área de preparación (staging area).</li>
      <li> Confirmas los cambios, lo que toma los archivos tal y como están en el
        área de preparación, y almacena esa instantánea de manera permanente
        en tu directorio de Git (git directory).</li>
    </ul><p>
      <p class="subtitulo">Repaso de algunos conceptos útiles</p>
      <p class="content">
<ul><li> Repositorio: Un repositorio contiene la historia, las diferentes versiones en
el tiempo y todas las diferentes ramas. En Git cada copia del repositorio
es un repositorio completo. Si el repositorio en el que estás trabajando no
es creado con la opción “bare”, entonces permite hacer un checkout de las
revisiones que desees en tu repositorio local.</li>
<li> Working tree: Posee el contenido de un commit que se puede obtener
haciendo un checkout desde un repositorio git. Luego uno puede modificar
ese contenido y hacer un nuevo commit con los cambios al repositorio</li>
<li> Branch (rama): Un branch es un puntero con un nombre determinado por
el usuario que apunta a un commit. Posicionarse en un branch utilizando
git es denominado como “hacer un checkout” de ese branch. Si estás
trabajando en un determinado branch, la creación de un nuevo commit
hace avanzar el puntero a esta nueva instancia. Cada commit conoce
sus antecesores así como a sus sucesores en caso de tenerlos. Uno de los
branches es el default, generalmente llamado master</li>
<li> Tag: Un tag apunta a un commit que unívocamente identifica una versión
del repositorio. Con un tag, podés tener un puntero con nombre al que
siempre puedas revertir los cambios. Por ejemplo, la versión de 25.01.2009
del branch “testing”</li>
<li> Commit: Vos commiteas los cambios a un repositorio. Esto crea un nuevo
objeto commit en el repositorio que unívocamente identifica una nueva
versión del contenido del repositorio. Esta revisión puede ser consultada
posteriormente, por ejemplo si uno quiere ver el código fuente de una
versión anterior. Cada commit posee metadata que nos informa acerca
del autor, la fecha y otros datos que nos pueden resultar prácticos a la
hora de tratar de encontrar uno determinado.</li>

<li>• URL: Una URL en Git determina la ubicación de un repositorio. Revisión:
Representa una versión del código fuente. Git implementa las revisiones
de la misma manera que los objetos commit. </li>
<li> HEAD: Es un objeto simbólico que apunta generalmente al branch sobre
el que estamos trabajando (lo que también conocemos como “checked
out branch”). Si uno cambia de un branch al otro el HEAD apunta al
último commit del branch seleccionado. Si uno hace un checkout de un
determinado commit, el HEAD apunta a ese commit.</li>
<li> Staging area: Es el lugar en el que se almacenan los cambios del working
tree previos al commit. Es decir, contiene el set de cambios relevantes
para el próximo commit.</li>
<li> Index: Es un término alternativo para referirnos al staging area</p></li>

     <h3>Comandos básicos en Git</h3>
       <p class="content">crea un repositorio nuevo</p>
      <p class='answer'>Crea un directorio nuevo, ábrelo y ejecuta
          <code>git init </code>
          para crear un nuevo repositorio de git.<p>
        <img src="gitInit.png">
        <p class="question">hacer checkout a un repositorio<p>
Crea una copia local del repositorio ejecutando
<code>git clone /path/to/repository</code>
Si utilizas un servidor remoto, ejecuta
<code>git clone username@host:/path/to/repository</code>
</p>
<img src="madeClone.png">

       <h3>Añadiendo nuevos ficheros</h3>
<p>Así que tenemos un repositorio, pero no hay nada en ella. Puede agregar archivos con el comando add.
<code>git add filename</code></p>
<img src="gitAdd.png">

<p class=""></p>
         <p class="question">Cometer un Versión</p>
<p class='answer'><p>
Ahora que hemos añadido estos archivos, queremos que se pueden almacenar en realidad en el repositorio Git. Hacemos esto de enviarlos al repositorio.
<code>git commit -m "Adding files"</code></p>
<img src="gitCommit.png">

        <p class='answer'>Estado del git<p>
          <p class="question">Muestra el estado del árbol de trabajo <code>git status</code></p>
          <img src="gitStatus.png">


         <p class='answer'>envío de cambios<p>
        <p class="question">Resulta útil pensar en los branches como contextos, ya que es la forma en que
se usan más a menudo. Cuando realizas cambios de ramas, se cambian los
contextos en que se están trabajando y podés rápidamente cambiar de contexto
entre las diferentes ramas.</p>

   <p class='answer'>Deshace cambios y commits<p>
     <p class='question'> <code>git reset HEAD </code>deshacer el último commit y sacar del staging area
los archivos modificados</p>

<p class='answer'>Remueve archivos del staging area<p>
  <p class='question'> <code>git rm</code>Saca la entrada del archivo en el index, de manera que no va a ser tenido
más en cuenta para el próximo commit.</p>

   <h3>Creando y administrando ramas</h3>

   <p class='answer'>git branch </p>
     <p class='question'> <code>git branch</code>Listará las ramas locales que tengas.</p>

  <p class='answer'>git branch (name_newBranch)</p>
    <p class='question'> <code>>git branch (name_newBranch)</code>Crear una nueva rama y cambiar a ella</p>

  <p class='answer'>git branch -d (name_delBranch)</p>
    <p class='question'> <code>git branch -d (name_delBranch)</code>Eliminará la rama </p>

  <p class='answer'> git checkout -b (name_newBranch) </p>
    <p class='question'> <code> git checkout -b (name_newBranch)</code>Crear y cambiar inmediatamente a la nueva rama</p>

  <p class='answer'>git merge</p>
    <p class='question'> <code> git merge (branch)</code>Combinar la rama especificada en la rama actual.</p>
<img src="gitMerge.png" >

<p class='answer'>git log</p>
  <p class='question'> <code> git log --oneline </code>Muestra  la historia del desarrollo de este proyecto</p>
  <img src="gitLog.png" >


<p class='answer'>git log --oneline --graph</p>
  <p class='question'> <code>git log --oneline --graph</code>Podemos ver más claramente cuando las ramas se separaron y luego
cuando se fusionaron de nuevo.</p>
  <img src="gitLogGraph.png" >

  <p class='answer'>git tag </p>
    <p class='question'> <code> git -a v1.0 </code> El comando tag, básicamente, consiste en poner un marcador permanente en un commit en concreto
para que pueda ser usado para comparar con otro commit en el futuro. </p>
    <img src="gitTag.png" >

       <h3>Intercambio y actualización de Proyectos</h3>
       <p class='answer'>git pull </p>
         <p class='question'> <code> git pull (github) </code> busca en un repositorio remoto y trata de combinar en la
rama actual lo que trajo del remoto. </p>

<p class='answer'>git fetch </p>
  <p class='question'> <code> git fetch (github)  </code> se usa para sincronizar el repositorio local con otro remoto, bajando los datos
no tenes a nivel local </p>

<p class='answer'>git push </p>
  <p class='question'> <code> git push (github)   </code> Actualiza las refs remotas usando refs locales, mientras envía objetos necesarios para completar las refs dadas </p>





         <img src="gitRes.png" >












  <body>
</html>
