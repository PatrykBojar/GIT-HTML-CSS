<html>

<head>
    <link rel="stylesheet" href="estilo.css">


</head>

<body>

    <div class="menuVertical">

      <ul id="navigationMenu">
    <li>
	    <a class="home" href="#">
            <span>Home</span>
        </a>
    </li>

    <li>
    	<a class="about" href="#">
            <span>About</span>
        </a>
    </li>

    <li>
	     <a class="services" href="#">
            <span>Services</span>
         </a>
    </li>

    <li>
    	<a class="portfolio" href="#">
            <span>Portfolio</span>
        </a>
    </li>

    <li>
    	<a class="contact" href="#">
            <span>Contact us</span>
        </a>
    </li>
</ul>

    </div>


    <div class="content">

        <h1>Git</h1>
        <p class="comandos">
            <p class="answer">¿Qué es un sistema de control de versiones?</p>

            <p class="question">Un sistema de control de versiones (CVS) te permite realizar un seguimiento de la historia de una colección de archivos y además incluye la funcionalidad de revertir a una versión anterior.a colección de archivos usualmente es código fuente
                de algún lenguaje de programación, sin embargo, un sistema de control de versiones funciona con cualquier tipo de archivo</p>
        </p>
        <p class="comandos">
            <p class="answer">¿Qué es sistema de control de versiones distribuidas?</p>


            <p class="question">Un sistema de control de versiones distribuida tiene un servidor central para guardar el repositorio y cada ususario puede hacer una copia completa del repositorio central y por ser una copia completa tiene las misma funcionalidades que el
                repositoriuo original
            </p>
          <div class="uno">

          <img  src="whatISgit.png">
          </div>
        </p>
        <p class="comandos">
            <p class="answer">¿Qué es Git</p>
            <p class="question">Es un sistema de control de versiones distribuida que tiene su origen a partir del del desarrollo de kernel de Linux. Es muy utilizado por proyectos comerciales de verciones como Android o Eclipse. Git modela sus datos más como un conjunto
                de instantáneas de un mini sistema de archivos Cada vez que confirmas un cambio, o guardas el estado de tu proyecto en Git </p>

        <p class="subtitulo">El repositorio local</p>
        <p class="content1">Luego de clonar o crear un repositorio el usuario tiene una copia completa del repositorio, y puede realizar operaciones de control de versiones contra este repositorio local, como por ejemplo crear nuevas versiones, revertir cambios, etc. El
            flujo de trabajo básico en Git es algo así </p>
        <ul>
            <li>Modificas una serie de archivos en tu directorio de trabajo (working directory).</li>
            <li> Añadís instantáneas de los archivos a tu área de preparación (staging area).</li>
            <li> Confirmas los cambios, lo que toma los archivos tal y como están en el área de preparación, y almacena esa instantánea de manera permanente en tu directorio de Git (git directory).</li>
        </ul>

        <p class="answer">Repaso de algunos conceptos útiles</p>

        <ul>
            <li> Repositorio: Un repositorio contiene la historia, las diferentes versiones en el tiempo y todas las diferentes ramas. En Git cada copia del repositorio es un repositorio completo. Si el repositorio en el que estás trabajando no es creado con
                la opción “bare”, entonces permite hacer un checkout de las revisiones que desees en tu repositorio local.</li>
            <li> Working tree: Posee el contenido de un commit que se puede obtener haciendo un checkout desde un repositorio git. Luego uno puede modificar ese contenido y hacer un nuevo commit con los cambios al repositorio</li>
            <li> Branch (rama): Un branch es un puntero con un nombre determinado por el usuario que apunta a un commit. Posicionarse en un branch utilizando git es denominado como “hacer un checkout” de ese branch. Si estás trabajando en un determinado branch,
                la creación de un nuevo commit hace avanzar el puntero a esta nueva instancia. Cada commit conoce sus antecesores así como a sus sucesores en caso de tenerlos. Uno de los branches es el default, generalmente llamado master
            </li>
            <li> Tag: Un tag apunta a un commit que unívocamente identifica una versión del repositorio. Con un tag, podés tener un puntero con nombre al que siempre puedas revertir los cambios. Por ejemplo, la versión de 25.01.2009 del branch “testing”
            </li>
            <li> Commit: Vos commiteas los cambios a un repositorio. Esto crea un nuevo objeto commit en el repositorio que unívocamente identifica una nueva versión del contenido del repositorio. Esta revisión puede ser consultada posteriormente, por ejemplo
                si uno quiere ver el código fuente de una versión anterior. Cada commit posee metadata que nos informa acerca del autor, la fecha y otros datos que nos pueden resultar prácticos a la hora de tratar de encontrar uno determinado.
            </li>

            <li>• URL: Una URL en Git determina la ubicación de un repositorio. Revisión: Representa una versión del código fuente. Git implementa las revisiones de la misma manera que los objetos commit. </li>
            <li> HEAD: Es un objeto simbólico que apunta generalmente al branch sobre el que estamos trabajando (lo que también conocemos como “checked out branch”). Si uno cambia de un branch al otro el HEAD apunta al último commit del branch seleccionado.
                Si uno hace un checkout de un determinado commit, el HEAD apunta a ese commit.</li>
            <li> Staging area: Es el lugar en el que se almacenan los cambios del working tree previos al commit. Es decir, contiene el set de cambios relevantes para el próximo commit.</li>
            <li> Index: Es un término alternativo para referirnos al staging area</li>
        </ul>
        </p>

        <h3>Comandos básicos en Git</h3>


        <p class="comandos">
            <p class="answer">Crea un directorio nuevo, ábrelo y ejecuta
                <br><code>git init </code></br> para crear un nuevo repositorio de git.
            </p>


            <img src="gitInit.png">
            <p class="question">hacer checkout a un repositorio</p>
        </p>
        <p class="comandos">
            <p class="answer">Crea una copia local del repositorio ejecutando
                <br><code>git clone /path/to/repository</code></br> Si utilizas un servidor remoto, ejecuta
                <br><code>git clone username@host:/path/to/repository</code></br>
            </p>
            <img src="madeClone.png">
        </p>
        <h3>Añadiendo nuevos ficheros</h3>


        <p class="comandos">
            <p>Así que tenemos un repositorio, pero no hay nada en ella. Puede agregar archivos con el comando add.
                <br><code>git add filename</code></br>
            </p>
            <img src="gitAdd.png">
        </p>
        <p class="comandos">
            <p class="answer">Realizar un commit</p>
            <p class="question"> Ahora que hemos añadido estos archivos, queremos que se pueden almacenar en realidad en el repositorio Git. Hacemos esto de enviarlos al repositorio.
                <br><code>git commit -m "Adding files"</code></br>
            </p>
            <img src="gitCommit.png">
        </p>

        <p class="comandos">
            <p class="answer">Estado del git </p>
            <p class="question">Muestra el estado del árbol de trabajo <br><code>git status</code></br>
            </p>
            <img src="gitStatus.png">

        </p>
        <p class="comandos">
            <p class="answer">Envío de cambios</p>
            <p class="question">Resulta útil pensar en los branches como contextos, ya que es la forma en que se usan más a menudo. Cuando realizas cambios de ramas, se cambian los contextos en que se están trabajando y podés rápidamente cambiar de contexto entre las diferentes
                ramas.
            </p>
        </p>
        <p class="comandos">
            <p class="answer">Deshace cambios y commits </p>
            <p class="question"> Deshace el último commit y sacar del staging area los archivos modificados<br><code>git reset HEAD </code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">Remueve archivos del staging area
            </p>
            <p class="question"> Saca la entrada del archivo en el index, de manera que no va a ser tenido más en cuenta para el próximo commit.<br><code>git rm</code></br>
            </p>
        </p>
        <h3>Creando y administrando ramas</h3>

        <p class="comandos">
            <p class="answer">git branch </p>
            <p class="question"> Listará las ramas locales que tengas.<br><code>git branch</code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">git branch</p>
            <p class="question">Crear una nueva rama y cambiar a ella <br><code>git branch (name_newBranch)</code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">git branch -d</p>
            <p class="question">Eliminará la rama <br><code>git branch -d (name_delBranch)</code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer"> git checkout -b </p>
            <p class="question">Crear y cambiar inmediatamente a la nueva rama <br><code> git checkout -b (name_newBranch)</code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">git merge</p>
            <p class="question"> Combinar la rama especificada en la rama actual.<br><code> git merge (branch)</code></br>
            </p>
            <img src="gitMerge.png">
        </p>
        <p class="comandos">
            <p class="answer">git log</p>
            <p class="question"> Muestra la historia del desarrollo de este proyecto<br><code> git log --oneline </code></br>
            </p>
            <img src="gitLog.png">

        </p>
        <p class="comandos">
            <p class="answer">git log --oneline --graph</p>
            <p class="question"> Podemos ver más claramente cuando las ramas se separaron y luego cuando se fusionaron de nuevo.<br><code>git log --oneline --graph</code></br>
            </p>
            <img src="gitLogGraph.png">
        </p>
        <p class="comandos">
            <p class="answer">git tag </p>
            <p class="question"> El comando tag, básicamente, consiste en poner un marcador permanente en un commit en concreto para que pueda ser usado para comparar con otro commit en el futuro.
                <br><code> git -a v1.0 </code></br>
            </p>
            <img src="gitTag.png">
        </p>
        <h3>Intercambio y actualización de Proyectos</h3>
        <p class="comandos">
            <p class="answer">git pull </p>
            <p class="question"> Busca en un repositorio remoto y trata de combinar en la rama actual lo que trajo del remoto.<br><code> git pull (github) </code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">git fetch </p>
            <p class="question"> Se usa para sincronizar el repositorio local con otro remoto, bajando los datos no tenes a nivel local. <br><code> git fetch (github)  </code></br>
            </p>
        </p>
        <p class="comandos">
            <p class="answer">git push </p>
            <p class="question"> Actualiza las refs remotas usando refs locales, mientras envía objetos necesarios para completar las refs dadas <br><code> git push (github)   </code></br>
            </p>

            <img src="gitRes.png">
        </p>
    </div>

</body>

</html>
